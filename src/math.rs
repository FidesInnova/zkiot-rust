// Copyright 2024 Fidesinnova, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Module for mathematical functions and utilities for finite field operations using the `u64` type and polynomials.

use crate::field::fmath;
use crate::json_file::ClassDataJson;
use crate::kzg;
use crate::polynomial::poly_fmath;
use crate::polynomial::FPoly;
use crate::println_dbg;
use crate::utils::add_random_points;
use nalgebra::DMatrix;
use std::collections::HashMap;
use std::collections::HashSet;

/// Type alias for a 2D point in the `u64` field.
pub type Point = (u64, u64);


/// Interpolates a polynomial that passes through a given set of points using the Newton interpolation algorithm.
///
/// # Parameters
/// - `points`: A slice of `Point` tuples, where each tuple contains an x-coordinate and a corresponding y-coordinate.
///
/// # Returns
/// A `Poly` representing the interpolating polynomial that passes through the provided points.
pub fn interpolate(points: &[Point], p: u64) -> FPoly {
    let n = points.len();
    let mut divided_differences = vec![vec![0; n]; n];

    // Initialize the divided differences table with y-values
    for (i, (_, y)) in points.iter().enumerate() {
        divided_differences[i][0] = *y;
    }

    // Compute the divided differences table
    for j in 1..n {
        for i in 0..(n - j) {
            let x_i = points[i].0;
            let x_ij = points[i + j].0;
            let numerator = fmath::sub(divided_differences[i + 1][j - 1], divided_differences[i][j - 1], p);
            let denominator = fmath::sub(x_ij, x_i, p);
            divided_differences[i][j] = fmath::div(numerator, denominator, p);
        }
    }

    // Build the Newton polynomial
    let mut poly_res = FPoly::new(vec![divided_differences[0][0]]);
    let mut poly_term = FPoly::one();

    for i in 1..n {
        let x_i = u64::from(points[i - 1].0);
        let new_term = FPoly::new(vec![1, fmath::inverse_add(x_i, p)]);
        poly_term = poly_fmath::mul(&poly_term, &new_term, p); // Multiply by (x - x_i) for each term
        let poly_product = poly_fmath::mul_by_number(&poly_term, divided_differences[0][i], p);
        poly_res = poly_fmath::add(&poly_res, &poly_product, p);
    }

    poly_res
}

/// Generates a vector of elements in the finite field `u64` based on the given
/// generator and length.
///
/// # Parameters
/// - `ms_gen`: The generator value for the finite field.
/// - `len`: The number of elements to generate.
///
/// # Returns
/// Returns a vector of `u64` elements, where each element is generated by raising
/// the generator `ms_gen` to increasing powers from 0 to `len - 1`.
///
/// # Description
/// This function generates a set of field elements using the specified generator
/// and length. Each element in the resulting vector is computed as `ms_gen^i`, where
/// `i` ranges from 0 to `len - 1`.
pub fn generate_set(len: u64, class_data: ClassDataJson, p: u64) -> Vec<u64> {
    let g = fmath::pow(class_data.g, (class_data.p - 1) / len, p); // Compute the generator for set H
    (0..len).map(|i| fmath::pow(g, i, p)).collect()
}

/// Computes the vanishing polynomial for a given set of field elements.
///
/// # Parameters
/// - `set`: A reference to a vector of `u64` elements representing the roots of the polynomial.
///
/// # Returns
/// Returns a `Poly` representing the vanishing polynomial with the provided roots.
///
/// # Description
/// This function constructs a polynomial with the given field elements as its roots. The resulting polynomial
/// will be zero at each of these field elements. The polynomial is built by multiplying linear factors corresponding
/// to each root.
pub fn vanishing_poly(set: &Vec<u64>, p: u64) -> FPoly {
    let mut vp = FPoly::one();

    for i in set {
        let product = poly_fmath::sub(&FPoly::one_x(), &FPoly::new(vec![*i]), p);
        vp = poly_fmath::mul(&product, &vp, p);
    }

    vp.trim();
    vp
}

/// Computes the value at specific points of a matrix `mat` based on the sets `set_h` and `set_k`,
/// and the mappings `row_k` and `col_k`. It evaluates a polynomial `poly_u` at these points
/// and divides the matrix value by the product of the evaluated values.
///
/// # Parameters
/// - `mat`: A reference to the matrix `mat` of type `DMatrix<u64>`.
/// - `set_h`: A vector of values in the finite field `u64`, used as part of the polynomial evaluation.
/// - `set_k`: A vector of values in the finite field `u64`, used to identify the specific point in the matrix.
/// - `row_k`: A reference to a `HashMap` that maps values in `set_k` to the corresponding row values.
/// - `col_k`: A reference to a `HashMap` that maps values in `set_k` to the corresponding column values.
///
/// # Returns
/// Returns a `HashMap<u64, u64>` where each key is a value from `set_k` and the value is the
/// computed polynomial division result at that matrix point.
///
/// # Description
/// The function iterates over the matrix `mat` and, for each non-zero element, computes a value
/// based on the evaluation of the polynomial `poly_u` at the points defined by `row_k` and `col_k`.
/// It then stores the result in the `res` map, associating it with the corresponding value from `set_k`.
///
/// # Panic
/// The function will panic if an index `c` in `set_k` is out of bounds or if `set_k` does not have
/// a value corresponding to the index `c`. This is asserted with `assert!(set_k.get(c).is_some());`.
pub fn get_matrix_point_val(
    mat: &DMatrix<u64>,
    set_h: &[u64],
    set_k: &[u64],
    row_k: &HashMap<u64, u64>,
    col_k: &HashMap<u64, u64>,
    n: usize, // set_h_len
    p: u64,
) -> HashMap<u64, u64> {
    let mut res = HashMap::new();
    let mut counter = 0;
    let mat_len = mat.nrows();

    let mut poly_u = FPoly::new(vec![0]);
    // FIXME: Check here
    poly_u.add_term(n as u64, n - 1);

    for i in 0..mat_len {
        for j in 0..mat_len {
            if mat[(i, j)] != 0 {
                let val = mat[(i, j)];
                assert!(set_k.get(counter).is_some());
                let k = set_k[counter];
                let mul_number = fmath::mul(
                    poly_u.evaluate(row_k[&k], p),
                    poly_u.evaluate(col_k[&k], p),
                    p,
                );
                let div_res = fmath::div(val, mul_number, p);
                let p2 = div_res;
                res.insert(set_k[counter], p2);
                counter += 1;
            }
        }
    }

    res
}

/// Maps non-zero elements of the matrix `mat` to the corresponding row values from `set_h`
/// based on the index in `set_k`.
///
/// # Parameters
/// - `mat`: A reference to the matrix `mat` of type `DMatrix<u64>`.
/// - `set_h`: A vector of values representing the rows in the finite field `u64`.
/// - `set_k`: A vector of values used to identify specific points in the matrix.
///
/// # Returns
/// Returns a `HashMap<u64, u64>` where each key is a value from `set_k` and the corresponding
/// value is the row value from `set_h`.
///
/// # Description
/// The function iterates over the matrix `mat` and, for each non-zero element,
/// maps the corresponding value in `set_k` to the row value in `set_h`.
pub fn get_matrix_point_row(mat: &DMatrix<u64>, set_h: &[u64], set_k: &[u64]) -> HashMap<u64, u64> {
    let mut res = HashMap::new();
    let mut counter = 0;
    let mat_len = mat.nrows();

    for i in 0..mat_len {
        for j in 0..mat_len {
            if mat[(i, j)] != 0 {
                res.insert(set_k[counter], set_h[i]);
                counter += 1;
            }
        }
    }

    add_random_points(&mut res, counter, set_h, set_k).unwrap();

    res
}

/// Maps non-zero elements of the matrix `mat` to the corresponding column values from `set_h`
/// based on the index in `set_k`.
///
/// # Parameters
/// - `mat`: A reference to the matrix `mat` of type `DMatrix<u64>`.
/// - `set_h`: A vector of values representing the columns in the finite field `u64`.
/// - `set_k`: A vector of values used to identify specific points in the matrix.
///
/// # Returns
/// Returns a `HashMap<u64, u64>` where each key is a value from `set_k` and the corresponding
/// value is the column value from `set_h`.
///
/// # Description
/// The function iterates over the matrix `mat` and, for each non-zero element,
/// maps the corresponding value in `set_k` to the column value in `set_h`.
pub fn get_matrix_point_col(mat: &DMatrix<u64>, set_h: &[u64], set_k: &[u64]) -> HashMap<u64, u64> {
    let mut res = HashMap::new();
    let mut c = 0;
    let mat_len = mat.nrows();

    for i in 0..mat_len {
        for j in 0..mat_len {
            if mat[(i, j)] != 0 {
                res.insert(set_k[c], set_h[j]);
                c += 1;
            }
        }
    }

    add_random_points(&mut res, c, set_h, set_k).unwrap();

    res
}

/// Retrieves the row points, column points, and computed polynomial values for non-zero elements
/// in the given matrix `mat` based on the provided sets `set_h` and `set_k`. The function
/// evaluates the necessary points and ensures the integrity of the results.
///
/// # Parameters
/// - `mat`: A reference to the matrix `mat` of type `DMatrix<u64>`.
/// - `set_h`: A vector of values in the finite field `u64`, used to identify the rows and columns.
/// - `set_k`: A vector of values in the finite field `u64`, used to specify the points in the matrix.
///
/// # Returns
/// Returns a tuple containing three `HashMap<u64, u64>`:
/// - The first map contains the row points.
/// - The second map contains the column points.
/// - The third map contains the computed polynomial values.
///
/// # Description
/// The function calls helper functions to gather the row points, column points, and polynomial
/// values for each non-zero element in the matrix. It asserts that the total number of row and
/// column points is twice the length of `set_k` to ensure consistency.
///
/// # Panic
/// The function will panic if the number of row and column points does not match the expected
/// count based on `set_k`.
pub fn get_matrix_points(
    mat: &DMatrix<u64>,
    set_h: &[u64],
    set_k: &[u64],
    p: u64,
) -> (HashMap<u64, u64>, HashMap<u64, u64>, HashMap<u64, u64>) {
    let row_p = get_matrix_point_row(mat, &set_h, &set_k);
    // Ensure that the number of row points matches the length of set_k.
    assert_eq!(row_p.len(), set_k.len());

    let col_p = get_matrix_point_col(mat, &set_h, &set_k);
    // Ensure that the number of col points matches the length of set_k.
    assert_eq!(col_p.len(), set_k.len());

    let val_p = get_matrix_point_val(mat, &set_h, &set_k, &row_p, &col_p, set_h.len(), p);

    (row_p, col_p, val_p)
}

/// Represents the order of evaluation for polynomial computations.
///
/// The `EvalOrder` enum has two variants:
/// - `XK`: Indicates that the polynomial should be evaluated in the XK order.
/// - `KX`: Indicates that the polynomial should be evaluated in the KX order.
pub enum EvalOrder {
    XK,
    KX,
}

/// Computes a polynomial `m_k` based on the provided `points_val`, `points_row`, and `points_col`.
///
/// This function combines the functionality of the previous `m_xk` and `m_kx` functions into a single
/// function that computes a polynomial based on the specified evaluation order. The evaluation order
/// determines whether the polynomial is evaluated in the `XK` or `KX` manner.
///
/// # Parameters
/// - `num`: A reference to an `u64` element, used to evaluate the resulting polynomial.
/// - `points_val`: A `HashMap` mapping points to their corresponding `u64` values.
/// - `points_row`: A `HashMap` mapping points to their corresponding row values in the matrix.
/// - `points_col`: A `HashMap` mapping points to their corresponding column values in the matrix.
/// - `set_h_len`: The length of the set `H`, which determines the degree of the polynomial.
/// - `eval_order`: An `EvalOrder` enum value that specifies the order of evaluation (either `XK` or `KX`).
///
/// # Returns
/// Returns a `Poly` representing the result of summing up the products of the evaluated polynomials.
///
/// # Description
/// This function iterates over each key-value pair `(k, val)` in `points_val`, and for each pair:
/// 1. Constructs a polynomial `poly_val` from the value `val`.
/// 2. Constructs two polynomials `poly_x` and `poly_y` using the `func_u` function, with `points_row[k]` and `points_col[k]` as inputs, respectively.
/// 3. Depending on the specified `eval_order`, it evaluates either `poly_y` at `num` (for `XK`) or `poly_x` at `num` (for `KX`).
/// 4. Multiplies the evaluated polynomial with `poly_val` and the other polynomial, then sums these products to obtain the final polynomial `poly_res`.
///
/// # Notes
/// - The final polynomial depends on the evaluation order specified by `eval_order`.
/// - This function provides a unified way to compute the polynomial interactions based on the evaluation context.
pub fn m_k(
    num: &u64,
    points_val: &HashMap<u64, u64>,
    points_row: &HashMap<u64, u64>,
    points_col: &HashMap<u64, u64>,
    set_h_len: usize,
    eval_order: &EvalOrder,
    p: u64,
) -> FPoly {
    // FIXME: use FPoly::zero?
    let mut poly_res = FPoly::new(vec![0]);

    let mut catch: HashMap<u64, FPoly> = HashMap::new();

    // eprintln!("val len: {}", points_val.len());

    for (k, h) in points_val {
        // let timer = std::time::Instant::now();
        let poly_x = catch
            .entry(points_row[k])
            .or_insert_with(|| poly_func_u(None, Some(points_row[k]), set_h_len, p))
            .clone();

        let poly_y = catch
            .entry(points_col[k])
            .or_insert_with(|| poly_func_u(None, Some(points_col[k]), set_h_len, p))
            .clone();
        // final_time += timer.elapsed();
        let tmp_result = match eval_order {
            EvalOrder::XK => {
                let res_poly_y = poly_y.evaluate(*num, p);
                let mul_nums = fmath::mul(*h, res_poly_y, p);
                poly_fmath::mul_by_number(&poly_x, mul_nums, p)
            }
            EvalOrder::KX => {
                let res_poly_x = poly_x.evaluate(*num, p);
                let mul_nums = fmath::mul(*h, res_poly_x, p);
                poly_fmath::mul_by_number(&poly_y, mul_nums, p)
            }
        };
        poly_res = poly_fmath::add(&poly_res, &tmp_result, p); 
    }

    poly_res
}

pub fn m_k_2(
    num: &u64,
    points_val: &HashMap<u64, u64>,
    points_row: &HashMap<u64, u64>,
    points_col: &HashMap<u64, u64>,
    catch: &HashMap<u64, FPoly>,
    eval_order: &EvalOrder,
    p: u64,
) -> FPoly {
    // FIXME: use FPoly::zero?
    let mut poly_res = FPoly::new(vec![0]);

    let mut ftime = std::time::Duration::new(0, 0);

    for (set_k_items, value) in points_val {
        // Retrieve corresponding row and column points
        let point_row = &points_row[set_k_items];
        let point_col = &points_col[set_k_items];

        // Access precomputed values from catch
        let poly_x = &catch[point_row];
        let poly_y = &catch[point_col];

        let timer = std::time::Instant::now();
        let tmp_result = match eval_order {
            EvalOrder::XK => {
                let res_poly_y = poly_y.evaluate(*num, p);
                let mul_poly = FPoly::new(vec![(*value * res_poly_y)]);
                poly_fmath::mul(&poly_x, &mul_poly, p)
            }
            EvalOrder::KX => {
                let res_poly_x = poly_x.evaluate(*num, p);
                let mul_poly = FPoly::new(vec![(*value * res_poly_x)]);
                poly_fmath::mul(&poly_y, &mul_poly, p)
            }
        };
        poly_res = poly_fmath::add(&poly_res, &tmp_result, p);
        ftime += timer.elapsed();
    }
    // eprintln!("timer - in: {:?}", ftime);
    poly_res
}

/// Computes the polynomial `u(x, y)` defined as:
/// u(x, y) = (x^n - y^n) / (x - y) = x^(n-1) + x^(n-2)y + x^(n-3)y^2 + ... + y^(n-1).
///
/// This function takes two optional inputs `x` and `y` of type `Option<u64>` and computes the
/// polynomial based on the given inputs:
/// - If `x` is `None` and `y` is `Some`, it generates the terms `y^k` for `k` in `[0, degree)`.
/// - If `y` is `None` and `x` is `Some`, it generates the terms `x^k` for `k` in `[0, degree)`.
/// - If both `x` and `y` are `Some`, it computes the summation of terms
///   `x^(degree - 1 - k) * y^k` for `k` in `[0, degree)`.
/// - Panics if both `x` and `y` are `None`.
///
/// # Parameters
/// - `x`: An optional value of type `u64` representing the base `x`.
/// - `y`: An optional value of type `u64` representing the base `y`.
/// - `degree`: The degree of the polynomial.
///
/// # Returns
/// A `Poly` representing the resulting polynomial.
///
/// # Panics
/// Panics if both `x` and `y` are `None`.
///
pub fn poly_func_u(x: Option<u64>, y: Option<u64>, degree: usize, p: u64) -> FPoly {
    match (x, y) {
        (None, Some(y)) => {
            let mut vec_poly: Vec<u64> = Vec::with_capacity(degree);
            let mut current_power = 1;
            for _ in 0..degree {
                vec_poly.push(current_power);
                current_power = fmath::mul(current_power, y, p);
            }
            FPoly::new(vec_poly)
        },
        (Some(x), None) => {
            let mut vec_poly: Vec<u64> = Vec::with_capacity(degree);
            let mut current_power = 1;
            for _ in 0..degree {
                vec_poly.push(current_power);
                current_power = fmath::mul(current_power, x, p);
            }
            FPoly::new(vec_poly)
        },
        (Some(x), Some(y)) => {
            let mut result = 0;

            for k in 0..degree {
                let rhs = fmath::pow(y, k as u64, p);
                let lhs = fmath::pow(x, (degree - 1 - k) as u64, p);
                let mul_numbers = fmath::mul(lhs, rhs, p);
                result = fmath::add(result, mul_numbers, p);
            }

            FPoly::new(vec![result])
        },
        (None, None) => panic!("Both x and y cannot be None"),
    }
}

/// Computes the polynomial sum for `sigma_rkx_mkx` based on the provided set `H`, `alpha`, and points.
///
/// # Parameters
/// - `set_h`: A reference to a vector of `u64` elements representing the set `H`.
/// - `alpha`: An `u64` element used in the polynomial computation.
/// - `points_val`: A `HashMap` mapping points to their corresponding `u64` values.
/// - `points_row`: A `HashMap` mapping points to their corresponding row values in the matrix.
/// - `points_col`: A `HashMap` mapping points to their corresponding column values in the matrix.
/// - `eval_order`: A reference to an `EvalOrder` enum value that specifies the order of evaluation.
///
/// # Returns
/// Returns a `Poly` representing the sum of the products of polynomials.
///
/// # Description
/// This function iterates over each element `h` in `set_h`, and for each `h`:
/// 1. Constructs a polynomial `p_r_alphak` using `func_u`, which depends on `alpha` and `h`.
/// 2. Constructs a polynomial `p_m_kx` using the `m_k` function.
/// 3. Trims the polynomials to remove leading zeros.
/// 4. Multiplies `p_r_alphak` and `p_m_kx` and sums the result into `res`.
///
/// This function is used to compute the final polynomial based on the interaction between `alpha` and `h`.
pub fn sigma_rk_mk(
    set_h: &Vec<u64>,
    alpha: u64,
    points_val: &HashMap<u64, u64>,
    points_row: &HashMap<u64, u64>,
    points_col: &HashMap<u64, u64>,
    eval_order: &EvalOrder,
    g: u64,
    p: u64,
) -> FPoly {
    let mut res = FPoly::new(vec![0]);

    let mut catch: HashMap<u64, FPoly> =
        HashMap::with_capacity(points_row.len() + points_col.len());
    let unique_keys: HashSet<_> = points_row.values().chain(points_col.values()).collect();

    // Precompute func_u results for unique keys
    for &key in unique_keys {
        catch
            .entry(key)
            .or_insert_with(|| poly_func_u(None, Some(key), set_h.len(), p));
    }

    for h in set_h {
        let mut p_r_xk = poly_func_u(Some(alpha), Some(*h), set_h.len(), p);

        let timer = std::time::Instant::now();
        // FIXME: this part is expensive
        let mut p_m_kx = m_k_2(h, points_val, points_row, points_col, &catch, eval_order, p);
        // eprintln!("time2 : {:?}", timer.elapsed());

        p_r_xk.trim();
        p_m_kx.trim();

        // sigma
        let mul_poly = poly_fmath::mul(&p_r_xk, &p_m_kx, p);
        res = poly_fmath::add(&res, &mul_poly, p);
    }

    res
}

/// Calculates the sigma_m value based on the provided polynomials and parameters.
///
/// # Parameters
/// - `van_poly_vhx`: The Vandermonde polynomial evaluated at `v_h(x)`.
/// - `eta`: An `u64` value used as a multiplier in the result.
/// - `beta_1`: The first `u64` value to evaluate the Vandermonde polynomial.
/// - `beta_2`: The second `u64` value to evaluate the Vandermonde polynomial.
/// - `k`: The `u64` value used to evaluate the polynomials in the `polys` array.
/// - `polys`: A slice containing references to the row, column, and value polynomials
///   (in that order).
///
/// # Returns
/// Returns an `u64` value calculated as `eta * (nu / de)`, where `nu` is the product
/// of the Vandermonde polynomials evaluated at `beta_1` and `beta_2`, and `polys[2]` evaluated at `k`.
/// `de` is the product of differences between `beta_2` and `polys[0]` evaluated at `k`,
/// and `beta_1` and `polys[1]` evaluated at `k`.
pub fn sigma_m(
    van_poly_vhx: &FPoly,
    eta: &u64,
    beta_1: &u64,
    beta_2: &u64,
    k: &u64,
    polys: &[&FPoly],
    p: u64,
) -> u64 {
    // FIXME: Clean this function
    let numerator = fmath::mul(
        van_poly_vhx.evaluate(*beta_1, p),
        van_poly_vhx.evaluate(*beta_2, p),
        p,
    );
    let numerator = fmath::mul(numerator, polys[2].evaluate(*k, p), p);

    let sub1 = fmath::sub(*beta_2, polys[0].evaluate(*k, p), p);
    let sub2 = fmath::sub(*beta_1, polys[1].evaluate(*k, p), p);

    let denominator = fmath::mul(sub1, sub2, p);

    let div = fmath::div(numerator, denominator, p);

    fmath::mul(*eta, div, p)
}

/// Computes the Lagrange interpolation polynomial `L_i(y_i)` for a given set of points.
///
/// # Parameters
/// - `points`: A `HashMap` mapping points to their corresponding `u64` values.
/// - `set_k`: A reference to a vector of `u64` elements used to identify the points in the Lagrange interpolation.
///
/// # Returns
/// Returns a `Poly` object representing the Lagrange interpolation polynomial
/// based on the points in `set_k` and their corresponding values in `points`.
///
/// # Description
/// This function constructs a Lagrange interpolation polynomial using the points provided
/// in `set_k` and the corresponding values found in the `points` HashMap. If a point in `set_k`
/// does not have a corresponding value in `points`, it defaults to `u64::ZERO`.
pub fn sigma_yi_li(points: &HashMap<u64, u64>, set_k: &Vec<u64>, p: u64) -> FPoly {
    let mut points_li: Vec<Point> = vec![];
    for k in set_k {
        let val = points.get(k).unwrap_or(&0);
        points_li.push((*k, *val));
    }
    interpolate(&points_li, p)
}

/// Computes a pairing function based on the inputs `a`, `b`, and `g`.
///
/// This function calculates a modified pairing value by reducing `a` and `b`
/// modulo `g`, multiplying the results, and then scaling the product by a factor of 3.
///
/// # Parameters
/// - `a`: An `u64` value representing the first input to the pairing function.
/// - `b`: An `u64` value representing the second input to the pairing function.
/// - `g`: An `u64` value used as the modulus for reducing `a` and `b`.
///
/// # Returns
/// An `u64` value representing the result of the pairing computation.
pub fn e_func(a: u64, b: u64, g: u64, p: u64) -> u64 {
    println_dbg!("a: {a}, b: {b}");
    let a_r = fmath::div(a, g, p);
    let b_r = fmath::div(b, g, p);
    println_dbg!("a_r: {a_r}, b_r: {b_r}");
    let exp = fmath::mul(a_r, b_r, p);
    fmath::mul(3, exp, p)
}

/// Computes commitments for a list of polynomials using a given commitment key.
///
/// This function iterates over a slice of polynomials and computes a commitment for each polynomial
/// using the KZG commitment scheme. The results are collected in a vector and returned.
///
/// # Parameters
/// - `polys`: A slice of `Poly` representing the polynomials for which commitments are to be computed.
/// - `ck`: A reference to a vector of `u64` values representing the commitment key used in the KZG scheme.
///
/// # Returns
/// A vector of `u64` values, where each value represents the commitment for the corresponding polynomial.
pub fn compute_all_commitment(polys: &[FPoly], ck: &Vec<u64>, p: u64) -> Vec<u64> {
    let mut res = vec![];

    for poly in polys.iter() {
        let commitment_num = kzg::commit(&poly, &ck, p);
        res.push(commitment_num);
    }

    res
}

#[cfg(test)]
mod math_test {
    use super::*;

    #[test]
    fn test_func_u() {
        assert_eq!(FPoly::new(vec![1]), poly_func_u(Some(1), Some(0), 100, 181));
        assert_eq!(FPoly::new(vec![1]), poly_func_u(Some(0), Some(1), 100, 181));
        assert_eq!(FPoly::new(vec![70]), poly_func_u(Some(10), Some(1), 5, 181));
        assert_eq!(
            FPoly::new(vec![53]),
            poly_func_u(Some(123), Some(321), 10, 181)
        );
        assert_eq!(
            FPoly::new(vec![99]),
            poly_func_u(Some(2838193), Some(9728224), 50, 181)
        );
        assert_eq!(
            FPoly::new(vec![42]),
            poly_func_u(
                Some(18446744073709551614),
                Some(18446744073709551615),
                10,
                181
            )
        );

        assert_eq!(
            FPoly::new(vec![1, 10, 100, 95, 45]),
            poly_func_u(Some(10), None, 5, 181)
        );

        assert_eq!(
            FPoly::new(vec![1, 112, 55, 6, 129]),
            poly_func_u(None, Some(112), 5, 181)
        );
    }

    #[test]
    fn test_interpolate() {
        // Test case 1
        let points1 = vec![
            (1, 3),
            (4, 5),
            (10, 22),
            (111, 222),
            (0, 0),
            (1234, 4567),
            (122222, 1344556),
        ];
        // 91*x^6 + 147*x^5 + 109*x^4 + 69*x^3 + 100*x^2 + 30*x
        let expected_poly1 = FPoly::new(vec![91, 147, 109, 69, 100, 30, 0]);
        assert_eq!(expected_poly1, interpolate(&points1, 181));

        // Test case 2
        let points2 = vec![
            (1, 3),
            (4, 5),
            (10, 22),
            (111, 222),
            (0, 0),
            (0, 0), // Duplicate point
            (1234, 4567),
            (122222, 1344556),
        ];
        // 86*x^7 + 178*x^6 + 141*x^5 + 52*x^4 + 42*x^3 + 47*x^2
        let expected_poly2 = FPoly::new(vec![86, 178, 141, 52, 42, 47, 0, 0]);
        assert_eq!(expected_poly2, interpolate(&points2, 181));

        // Test case 3
        let points3 = vec![
            (39942, 123244),
            (41221133, 53534213),
            (12121210, 2424222),
            (1242411, 242422),
            (0, 0),
        ];
        // 68*x^4 + 70*x^3 + 35*x^2 + 146*x
        let expected_poly3 = FPoly::new(vec![68, 70, 35, 146, 0]);
        assert_eq!(expected_poly3, interpolate(&points3, 181));
    }
}
