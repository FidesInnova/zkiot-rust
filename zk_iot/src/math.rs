//! Module for mathematical functions and utilities for finite field operations using the `Mfp` type and polynomials.

use ark_ff::{Field, PrimeField};
use nalgebra::DMatrix;
use rustnomial::*;
use std::collections::HashMap;
use std::ops::Neg;

use crate::{field, to_bint};

/// Define the constant modulus for field operations.

// 2013265921
pub const P: u64 = 2013265921;
// pub const P: u64 = 181;

field!(Mfp, P);

/// Type alias for a polynomial over the `Mfp` field.
pub type Poly = Polynomial<Mfp>;

/// Type alias for a 2D point in the `Mfp` field.
pub type Point = (Mfp, Mfp);

/// Type alias for a 2D point and a value in the `Mfp` field.
pub type Point2d = (Point, Mfp);

/// Computes the modular exponentiation of `a` raised to the power `b`
/// and returns the result as an element of the finite field `Mfp`.
///
/// # Parameters
/// - `a`: The base value, of type `u64`.
/// - `b`: The exponent value, of type `u64`.
///
/// # Returns
/// Returns the result of `a^b` as an element of the finite field `Mfp`.
///
/// # Example
/// ```
/// use zk_iot::*;
///
/// let result = exp_mod(2, 10);
/// assert_eq!(result, Mfp::from(1024));
/// ```
pub fn exp_mod(a: u64, b: u64) -> Mfp {
    Mfp::from(a).pow([b])
}

/// Constructs a polynomial of the form u(x , y) = (x^degree - y^degree) / (x - y),
/// where either `x` or `y` is provided as an option.
///
/// # Parameters
/// - `x`: An optional value in the finite field `Mfp`. Only one of `x` or `y` should be `Some`.
/// - `y`: An optional value in the finite field `Mfp`. Only one of `x` or `y` should be `Some`.
/// - `degree`: The degree of the polynomial, of type `usize`.
///
/// # Returns
/// Returns the result of the polynomial division as a `Poly` object.
///
/// # Panics
/// The function panics if both `x` and `y` are either `None` or `Some`.
/// This ensures that exactly one of the parameters is provided.
pub fn func_u(x: Option<Mfp>, y: Option<Mfp>, degree: usize) -> Poly {
    if x.is_none() && y.is_none() {
        panic!("At least one of x or y must be Some.");
    }

    let mut numerator = Poly::new(vec![]);
    let mut denominator = Poly::new(vec![]);

    if let Some(x) = x {
        numerator.add_term(exp_mod(to_bint!(x), degree as u64), 0);
        numerator.add_term(-Mfp::ONE, degree);

        denominator.add_term(x, 0);
        denominator.add_term(-Mfp::ONE, 1);
    }
    if let Some(y) = y {
        numerator.add_term(-exp_mod(to_bint!(y), degree as u64), 0);
        numerator.add_term(Mfp::ONE, degree);

        denominator.add_term(-y, 0);
        denominator.add_term(Mfp::ONE, 1);
    }
    numerator.div_mod(&denominator).0
}

/// Performs Lagrange interpolation to find the polynomial that passes through
/// a given set of points.
///
/// # Parameters
/// - `points`: A vector of tuples where each tuple contains a point `(x_i, y_i)`
///   with `x_i` and `y_i` being coordinates in the finite field.
///
/// # Returns
/// Returns a `Poly` object representing the interpolated polynomial.
///
/// # Description
/// This function calculates the Lagrange basis polynomials for each point and
/// combines them to form the final polynomial that interpolates all given points.
/// For each point `(x_i, y_i)`, it constructs the Lagrange basis polynomial and
/// accumulates the weighted sum to form the final polynomial.
pub fn lagrange_interpolate(points: &[Point]) -> Poly {
    let mut poly_res: Poly = Poly::new(vec![Mfp::ZERO]);
    // let mut counter = 0;
    // println!("--- points: {:?}", points);

    for (x_i, y_i) in points.iter() {
        let mut poly_nume_all: Poly = Poly::new(vec![Mfp::ONE]);
        let mut poly_deno_all = Mfp::ONE;
        for (x_j, _) in points.iter() {
            if x_i != x_j {
                // Construct Lagrange basis polynomial for the current point
                let poly_nume: Poly = Poly::new(vec![Mfp::ONE, Mfp::from(*x_j).neg()]);
                let poly_deno = Mfp::from(*x_i) - Mfp::from(*x_j);

                // Accumulate the numerator and denominator for the basis polynomial
                poly_nume_all *= poly_nume;
                poly_deno_all *= poly_deno;
            }
        }
        // Add the weighted basis polynomial to the result
        poly_res += Poly::new(vec![*y_i]) * (poly_nume_all * poly_deno_all.inverse().unwrap());

        // counter += 1;
        // println!("L{}", counter);
        // dsp_poly!(poly_res);
    }

    // print!("--- poly: ");
    // dsp_poly!(poly_res);

    poly_res
}

/// Generates a vector of elements in the finite field `Mfp` based on the given
/// generator and length.
///
/// # Parameters
/// - `ms_gen`: The generator value for the finite field.
/// - `len`: The number of elements to generate.
///
/// # Returns
/// Returns a vector of `Mfp` elements, where each element is generated by raising
/// the generator `ms_gen` to increasing powers from 0 to `len - 1`.
///
/// # Description
/// This function generates a set of field elements using the specified generator
/// and length. Each element in the resulting vector is computed as `ms_gen^i`, where
/// `i` ranges from 0 to `len - 1`.
pub fn generate_set(ms_gen: u64, len: u64) -> Vec<Mfp> {
    (0..len).map(|i| exp_mod(ms_gen, i)).collect()
}

/// Computes the commitment of a list of polynomials using a specified degree and
/// generator.
///
/// # Parameters
/// - `o`: A vector of polynomials (`Vec<Poly>`) to commit.
/// - `d`: A degree value used in the computation.
/// - `g`: A generator value used in the computation.
///
/// # Returns
/// Returns a vector of `Mfp` values representing the commitments of the input polynomials.
///
/// # Description
/// This function computes a commitment for each polynomial in the vector `o` using
/// the given degree `d` and generator `g`. It performs the commitment calculation
/// by evaluating each polynomial and multiplying the results, adjusting based on the
/// degree and generator. If the result of the commitment is `Mfp::ONE`, it defaults to
/// the generator value `g`.
///
pub fn commit(o: &Vec<Poly>, d: u64, g: u64) -> Vec<Mfp> {
    let mut res = vec![];

    for poly in o {
        let mut res_poly = Mfp::ONE;

        if let Degree::Num(deg) = poly.degree() {
            let mut s = Mfp::from(g);
            let d = d % (P - 1);

            for i in 0..=deg {
                let coef = poly.terms[deg - i].into_bigint().0[0];
                let value = exp_mod(s.into_bigint().0[0], coef);
                res_poly *= value;
                s = exp_mod(s.into_bigint().0[0], d);
            }
        }

        if res_poly == Mfp::ONE {
            res.push(Mfp::from(g));
        } else {
            res.push(res_poly);
        }
    }

    res
}

/// Generates a vector of field elements based on a given generator and parameters.
///
/// # Parameters
/// - `ms_gen`: The generator value for the finite field.
/// - `n`: The upper bound index for generating elements.
/// - `t`: The starting index for generating elements.
/// - `len`: The total length of the resulting vector.
///
/// # Returns
/// Returns a vector of `Mfp` elements. The vector starts with elements generated by raising
/// the generator `ms_gen` to powers from `t` to `n - 1`. If the vector length `len` is greater
/// than the number of generated elements, the remaining space is filled with zeros.
///
/// # Description
/// This function generates field elements using the specified generator for indices starting
/// from `t` up to `n - 1`. If the total length of the vector is greater than the number of
/// generated elements, the function appends zeros to the end of the vector to reach the
/// specified length.
///
/// # Panics
/// Panics if the calculated number of zeros to be appended is negative. This is ensured by the
/// assertion that `zeros >= 0`.
pub fn generate_set_eval(ms_gen: u64, n: usize, t: usize, len: usize) -> Vec<Mfp> {
    let mut set: Vec<Mfp> = vec![];
    for i in t..n {
        set.push(exp_mod(ms_gen, i as u64));
    }
    let zeros = len as isize - n as isize + t as isize;

    assert!(zeros >= 0);

    if zeros > 0 {
        for _ in 0..zeros {
            set.push(Mfp::ZERO);
        }
    }
    set
}

/// Computes the vanishing polynomial for a given set of field elements.
///
/// # Parameters
/// - `set`: A reference to a vector of `Mfp` elements representing the roots of the polynomial.
///
/// # Returns
/// Returns a `Poly` representing the vanishing polynomial with the provided roots.
///
/// # Description
/// This function constructs a polynomial with the given field elements as its roots. The resulting polynomial
/// will be zero at each of these field elements. The polynomial is built by multiplying linear factors corresponding
/// to each root.
pub fn vanishing_poly(set: &Vec<Mfp>) -> Poly {
    let mut vp = Poly::new(vec![Mfp::ONE]);

    for i in set {
        vp *= Poly::new(vec![Mfp::ONE, Mfp::ZERO]) - Poly::new(vec![*i]);
    }
    vp.trim();
    vp
}

/// Computes the value at specific points of a matrix `mat` based on the sets `set_h` and `set_k`,
/// and the mappings `row_k` and `col_k`. It evaluates a polynomial `poly_u` at these points
/// and divides the matrix value by the product of the evaluated values.
///
/// # Parameters
/// - `mat`: A reference to the matrix `mat` of type `DMatrix<Mfp>`.
/// - `set_h`: A vector of values in the finite field `Mfp`, used as part of the polynomial evaluation.
/// - `set_k`: A vector of values in the finite field `Mfp`, used to identify the specific point in the matrix.
/// - `row_k`: A reference to a `HashMap` that maps values in `set_k` to the corresponding row values.
/// - `col_k`: A reference to a `HashMap` that maps values in `set_k` to the corresponding column values.
///
/// # Returns
/// Returns a `HashMap<Mfp, Mfp>` where each key is a value from `set_k` and the value is the
/// computed polynomial division result at that matrix point.
///
/// # Description
/// The function iterates over the matrix `mat` and, for each non-zero element, computes a value
/// based on the evaluation of the polynomial `poly_u` at the points defined by `row_k` and `col_k`.
/// It then stores the result in the `res` map, associating it with the corresponding value from `set_k`.
///
/// # Panic
/// The function will panic if an index `c` in `set_k` is out of bounds or if `set_k` does not have
/// a value corresponding to the index `c`. This is asserted with `assert!(set_k.get(c).is_some());`.
pub fn get_matrix_point_val(
    mat: &DMatrix<Mfp>,
    set_h: &[Mfp],
    set_k: &[Mfp],
    row_k: &HashMap<Mfp, Mfp>,
    col_k: &HashMap<Mfp, Mfp>,
) -> HashMap<Mfp, Mfp> {
    let mut res = HashMap::new();
    let mut c = 0;
    let mat_len = mat.nrows();

    let len = set_h.len();
    let mut poly_u = Poly::from(vec![Mfp::ZERO]);
    poly_u.add_term(Mfp::from(len as u64), len - 1);

    for i in 0..mat_len {
        for j in 0..mat_len {
            if mat[(i, j)] != Mfp::ZERO {
                let val = mat[(i, j)];
                assert!(set_k.get(c).is_some());
                let k = set_k[c];
                let p2 = val / (poly_u.eval(row_k[&k]) * poly_u.eval(col_k[&k]));
                res.insert(set_k[c], p2);
                c += 1;
            }
        }
    }

    res
}

/// Maps non-zero elements of the matrix `mat` to the corresponding row values from `set_h`
/// based on the index in `set_k`.
///
/// # Parameters
/// - `mat`: A reference to the matrix `mat` of type `DMatrix<Mfp>`.
/// - `set_h`: A vector of values representing the rows in the finite field `Mfp`.
/// - `set_k`: A vector of values used to identify specific points in the matrix.
///
/// # Returns
/// Returns a `HashMap<Mfp, Mfp>` where each key is a value from `set_k` and the corresponding
/// value is the row value from `set_h`.
///
/// # Description
/// The function iterates over the matrix `mat` and, for each non-zero element,
/// maps the corresponding value in `set_k` to the row value in `set_h`.
pub fn get_matrix_point_row(mat: &DMatrix<Mfp>, set_h: &[Mfp], set_k: &[Mfp]) -> HashMap<Mfp, Mfp> {
    let mut res = HashMap::new();
    let mut c = 0;
    let mat_len = mat.nrows();

    for i in 0..mat_len {
        for j in 0..mat_len {
            if mat[(i, j)] != Mfp::ZERO {
                res.insert(set_k[c], set_h[i]);
                c += 1;
            }
        }
    }
    res
}

/// Computes a polynomial `m_xk` based on the provided `points_val`, `points_row`, and `points_col`.
///
/// # Parameters
/// - `num`: A reference to an `Mfp` element, used to evaluate the resulting polynomial.
/// - `points_val`: A `HashMap` mapping points to their corresponding `Mfp` values.
/// - `points_row`: A `HashMap` mapping points to their corresponding row values in the matrix.
/// - `points_col`: A `HashMap` mapping points to their corresponding column values in the matrix.
/// - `set_h_len`: The length of the set `H`, which determines the degree of the polynomial.
///
/// # Returns
/// Returns a `Poly` representing the result of summing up the products of the evaluated polynomials.
///
/// # Description
/// This function iterates over each key-value pair `(k, val)` in `points_val`, and for each pair:
/// 1. Constructs a polynomial `poly_val` from the value `val`.
/// 2. Constructs two polynomials `poly_x` and `poly_y` using the `func_u` function, with `points_row[k]` and `points_col[k]` as inputs, respectively.
/// 3. Evaluates `poly_y` at `num` to get `res_poly_y`, then multiplies it by `poly_val` and `poly_x`.
/// 4. Sums up these products to obtain the final polynomial `poly_res`.
///
/// The function `m_kx` follows a similar process, but evaluates `poly_x` at `num` instead of `poly_y`.
///
/// # Notes
/// - `m_xk`: The final polynomial depends on `poly_x` and the evaluation of `poly_y` at `num`.
/// - `m_kx`: The final polynomial depends on `poly_y` and the evaluation of `poly_x` at `num`.
///
/// These two functions are used to compute different aspects of the overall polynomial interaction.
pub fn m_xk(
    num: &Mfp,
    points_val: &HashMap<Mfp, Mfp>,
    points_row: &HashMap<Mfp, Mfp>,
    points_col: &HashMap<Mfp, Mfp>,
    set_h_len: usize,
) -> Poly {
    let mut poly_res = Poly::from(vec![Mfp::ZERO]);

    for (k, val) in points_val {
        let poly_val = Poly::from(vec![*val]);
        let poly_x = func_u(None, Some(points_row[k]), set_h_len);
        let poly_y = func_u(None, Some(points_col[k]), set_h_len);
        let res_poly_y = poly_y.eval(*num);
        poly_res += poly_val * res_poly_y * poly_x;
    }

    poly_res
}

/// Computes a polynomial `m_kx` based on the provided `points_val`, `points_row`, and `points_col`.
///
/// # Parameters
/// - `num`: A reference to an `Mfp` element, used to evaluate the resulting polynomial.
/// - `points_val`: A `HashMap` mapping points to their corresponding `Mfp` values.
/// - `points_row`: A `HashMap` mapping points to their corresponding row values in the matrix.
/// - `points_col`: A `HashMap` mapping points to their corresponding column values in the matrix.
/// - `set_h_len`: The length of the set `H`, which determines the degree of the polynomial.
///
/// # Returns
/// Returns a `Poly` representing the result of summing up the products of the evaluated polynomials.
///
/// # Description
/// This function iterates over each key-value pair `(k, val)` in `points_val`, and for each pair:
/// 1. Constructs a polynomial `poly_val` from the value `val`.
/// 2. Constructs two polynomials `poly_y` and `poly_y` using the `func_u` function, with `points_row[k]` and `points_col[k]` as inputs, respectively.
/// 3. Evaluates `poly_y` at `num` to get `res_poly_y`, then multiplies it by `poly_val` and `poly_y`.
/// 4. Sums up these products to obtain the final polynomial `poly_res`.
///
/// The function `m_kx` follows a similar process, but evaluates `poly_y` at `num` instead of `poly_y`.
///
/// # Notes
/// - `m_xk`: The final polynomial depends on `poly_y` and the evaluation of `poly_y` at `num`.
/// - `m_kx`: The final polynomial depends on `poly_y` and the evaluation of `poly_y` at `num`.
///
/// These two functions are used to compute different aspects of the overall polynomial interaction.
pub fn m_kx(
    num: &Mfp,
    points_val: &HashMap<Mfp, Mfp>,
    points_row: &HashMap<Mfp, Mfp>,
    points_col: &HashMap<Mfp, Mfp>,
    set_h_len: usize,
) -> Poly {
    let mut poly_res = Poly::from(vec![Mfp::ZERO]);

    for (k, val) in points_val {
        let poly_val = Poly::from(vec![*val]);
        let poly_x = func_u(None, Some(points_row[k]), set_h_len);
        let poly_y = func_u(None, Some(points_col[k]), set_h_len);
        let res_poly_x = poly_x.eval(*num);
        poly_res += poly_val * res_poly_x * poly_y;
    }

    poly_res
}

/// Computes the polynomial sum for `sigma_rkx_mkx` based on the provided set `H`, `alpha`, and points.
///
/// # Parameters
/// - `set_h`: A reference to a vector of `Mfp` elements representing the set `H`.
/// - `alpha`: An `Mfp` element used in the polynomial computation.
/// - `points_val`: A `HashMap` mapping points to their corresponding `Mfp` values.
/// - `points_row`: A `HashMap` mapping points to their corresponding row values in the matrix.
/// - `points_col`: A `HashMap` mapping points to their corresponding column values in the matrix.
///
/// # Returns
/// Returns a `Poly` representing the sum of the products of polynomials.
///
/// # Description
/// This function iterates over each element `h` in `set_h`, and for each `h`:
/// 1. Constructs a polynomial `p_r_alphak` using `func_u`, which depends on `alpha` and `h`.
/// 2. Constructs a polynomial `p_m_kx` using the `m_kx` function.
/// 3. Trims the polynomials to remove leading zeros.
/// 4. Multiplies `p_r_alphak` and `p_m_kx` and sums the result into `res`.
///
/// This function is used to compute the final polynomial based on the interaction between `alpha` and `h`.
pub fn sigma_rkx_mkx(
    set_h: &Vec<Mfp>,
    alpha: Mfp,
    points_val: &HashMap<Mfp, Mfp>,
    points_row: &HashMap<Mfp, Mfp>,
    points_col: &HashMap<Mfp, Mfp>,
) -> Poly {
    let mut res = Poly::from(vec![Mfp::ZERO]);
    for h in set_h {
        let mut p_r_alphak = func_u(Some(alpha), Some(*h), set_h.len());
        let mut p_m_kx = m_kx(h, points_val, points_row, points_col, set_h.len());
        p_r_alphak.trim();
        p_m_kx.trim();
        let mul_poly = p_r_alphak * p_m_kx;
        res += mul_poly;
    }
    res
}

/// Computes the polynomial sum for `sigma_rxk_mxk` based on the provided set `H`, `alpha`, and points.
///
/// # Parameters
/// - `set_h`: A reference to a vector of `Mfp` elements representing the set `H`.
/// - `alpha`: An `Mfp` element used in the polynomial computation.
/// - `points_val`: A `HashMap` mapping points to their corresponding `Mfp` values.
/// - `points_row`: A `HashMap` mapping points to their corresponding row values in the matrix.
/// - `points_col`: A `HashMap` mapping points to their corresponding column values in the matrix.
///
/// # Returns
/// Returns a `Poly` representing the sum of the products of polynomials.
///
/// # Description
/// This function iterates over each element `h` in `set_h`, and for each `h`:
/// 1. Constructs a polynomial `p_r_alphak` using `func_u`, which depends on `alpha` and `h`.
/// 2. Constructs a polynomial `p_m_xk` using the `m_xk` function.
/// 3. Trims the polynomials to remove leading zeros.
/// 4. Multiplies `p_r_alphak` and `p_m_xk` and sums the result into `res`.
///
/// This function is used to compute the final polynomial based on the interaction between `alpha` and `h`.
pub fn sigma_rxk_mxk(
    set_h: &Vec<Mfp>,
    alpha: Mfp,
    points_val: &HashMap<Mfp, Mfp>,
    points_row: &HashMap<Mfp, Mfp>,
    points_col: &HashMap<Mfp, Mfp>,
) -> Poly {
    let mut res = Poly::from(vec![Mfp::ZERO]);
    for h in set_h {
        let mut p_r_alphak = func_u(Some(alpha), Some(*h), set_h.len());
        let mut p_m_xk = m_xk(h, points_val, points_row, points_col, set_h.len());
        p_r_alphak.trim();
        p_m_xk.trim();
        res += p_r_alphak * p_m_xk;
    }
    res
}

/// Calculates the sigma_m value based on the provided polynomials and parameters.
///
/// # Parameters
/// - `van_poly_vhx`: The Vandermonde polynomial evaluated at `v_h(x)`.
/// - `eta`: An `Mfp` value used as a multiplier in the result.
/// - `beta_1`: The first `Mfp` value to evaluate the Vandermonde polynomial.
/// - `beta_2`: The second `Mfp` value to evaluate the Vandermonde polynomial.
/// - `k`: The `Mfp` value used to evaluate the polynomials in the `polys` array.
/// - `polys`: A slice containing references to the row, column, and value polynomials
///   (in that order).
///
/// # Returns
/// Returns an `Mfp` value calculated as `eta * (nu / de)`, where `nu` is the product
/// of the Vandermonde polynomials evaluated at `beta_1` and `beta_2`, and `polys[2]` evaluated at `k`.
/// `de` is the product of differences between `beta_2` and `polys[0]` evaluated at `k`,
/// and `beta_1` and `polys[1]` evaluated at `k`.
pub fn sigma_m(
    van_poly_vhx: &Poly,
    eta: &Mfp,
    beta_1: &Mfp,
    beta_2: &Mfp,
    k: &Mfp,
    polys: &[&Poly],
) -> Mfp {
    let nu = van_poly_vhx.eval(*beta_1) * van_poly_vhx.eval(*beta_2) * polys[2].eval(*k);
    let de = (beta_2 - &polys[0].eval(*k)) * (beta_1 - &polys[1].eval(*k));
    let div = nu / de;
    eta * &div
}

/// Computes the Lagrange interpolation polynomial `L_i(y_i)` for a given set of points.
///
/// # Parameters
/// - `points`: A `HashMap` mapping points to their corresponding `Mfp` values.
/// - `set_k`: A reference to a vector of `Mfp` elements used to identify the points in the Lagrange interpolation.
///
/// # Returns
/// Returns a `Poly` object representing the Lagrange interpolation polynomial
/// based on the points in `set_k` and their corresponding values in `points`.
///
/// # Description
/// This function constructs a Lagrange interpolation polynomial using the points provided
/// in `set_k` and the corresponding values found in the `points` HashMap. If a point in `set_k`
/// does not have a corresponding value in `points`, it defaults to `Mfp::ZERO`.
pub fn sigma_yi_li(points: &HashMap<Mfp, Mfp>, set_k: &Vec<Mfp>) -> Poly {
    let mut points_li: Vec<Point> = vec![];
    for k in set_k {
        let val = points.get(k).unwrap_or(&Mfp::ZERO);
        points_li.push((*k, *val));
    }
    lagrange_interpolate(&points_li)
}

// h3​(β3​)vK​(β3​)=a(β3​)−b(β3​)(β3​g3​(β3​)+σ3/|K|​​)
pub fn check_equation_1(
    h_3x: &Poly,
    g_3x: &Poly,
    van_poly_vkx: &Poly,
    ax: &Poly,
    bx: &Poly,
    beta_3: &Mfp,
    sigma_3: &Mfp,
    set_k_len: usize,
) -> bool {
    println!("eq11: {}", h_3x.eval(*beta_3) * van_poly_vkx.eval(*beta_3));
    println!(
        "eq12: {}",
        ax.eval(*beta_3)
            - (bx.eval(*beta_3)
                * (*beta_3 * g_3x.eval(*beta_3) + *sigma_3 / Mfp::from(set_k_len as u64)))
    );

    h_3x.eval(*beta_3) * van_poly_vkx.eval(*beta_3)
        == ax.eval(*beta_3)
            - (bx.eval(*beta_3)
                * (*beta_3 * g_3x.eval(*beta_3) + *sigma_3 / Mfp::from(set_k_len as u64)))
}

// r(α,β2​)σ3 ​= h2​(β2​) vH​(β2​) + β2​g2​(β2​) +  σ2​​/∣H∣
pub fn check_equation_2(
    poly_r: &Poly,
    h_2x: &Poly,
    g_2x: &Poly,
    van_poly_vhx: &Poly,
    beta_2: &Mfp,
    sigma_2: &Mfp,
    sigma_3: &Mfp,
    set_h_len: usize,
) -> bool {
    println!("eq21: {}", poly_r.eval(*beta_2) * sigma_3);
    println!(
        "eq22: {}",
        h_2x.eval(*beta_2) * van_poly_vhx.eval(*beta_2)
            + *beta_2 * g_2x.eval(*beta_2)
            + *sigma_2 / Mfp::from(set_h_len as u64)
    );

    poly_r.eval(*beta_2) * sigma_3
        == h_2x.eval(*beta_2) * van_poly_vhx.eval(*beta_2)
            + *beta_2 * g_2x.eval(*beta_2)
            + *sigma_2 / Mfp::from(set_h_len as u64)
}

// s(β1​)+r(α,β1​)(∑M∈{A,B,C}​ηM​z^M​(β1​))−σ2​z^(β1​) = h1​(β1​)vH​(β1​) + β1​g1​(β1​) + σ1​/∣H∣
pub fn check_equation_3(
    poly_sx: &Poly,
    sum_1: &Poly,
    poly_z_hat_x: &Poly,
    h_1x: &Poly,
    g_1x: &Poly,
    van_poly_vhx: &Poly,
    beta_1: &Mfp,
    sigma_1: &Mfp,
    sigma_2: &Mfp,
    set_h_len: usize,
) -> bool {
    println!(
        "eq31: {}",
        poly_sx.eval(*beta_1) + sum_1.eval(*beta_1) - *sigma_2 * poly_z_hat_x.eval(*beta_1)
    );
    println!(
        "eq32: {}",
        h_1x.eval(*beta_1) * van_poly_vhx.eval(*beta_1)
            + *beta_1 * g_1x.eval(*beta_1)
            + *sigma_1 / Mfp::from(set_h_len as u64)
    );

    poly_sx.eval(*beta_1) + sum_1.eval(*beta_1) - *sigma_2 * poly_z_hat_x.eval(*beta_1)
        == h_1x.eval(*beta_1) * van_poly_vhx.eval(*beta_1)
            + *beta_1 * g_1x.eval(*beta_1)
            + *sigma_1 / Mfp::from(set_h_len as u64)
}

// z^A​(β1​)z^B​(β1​)−z^C​(β1​)=h0​(β1​)vH​(β1​)
pub fn check_equation_4(
    poly_ab_c: &Poly,
    poly_h_0: &Poly,
    van_poly_vhx: &Poly,
    beta_1: &Mfp,
) -> bool {
    println!("eq41: {}", poly_ab_c.eval(*beta_1));
    println!(
        "eq42: {}",
        poly_h_0.eval(*beta_1) * van_poly_vhx.eval(*beta_1)
    );

    poly_ab_c.eval(*beta_1) == poly_h_0.eval(*beta_1) * van_poly_vhx.eval(*beta_1)
}

pub fn verify(
    h_1x: &Poly,
    g_1x: &Poly,
    h_2x: &Poly,
    g_2x: &Poly,
    h_3x: &Poly,
    g_3x: &Poly,

    beta_1: &Mfp,
    sigma_1: &Mfp,
    beta_2: &Mfp,
    sigma_2: &Mfp,
    beta_3: &Mfp,
    sigma_3: &Mfp,

    ax: &Poly,
    bx: &Poly,
    poly_ab_c: &Poly,
    poly_h_0: &Poly,
    poly_r: &Poly,
    poly_sx: &Poly,
    poly_z_hat_x: &Poly,

    set_k_len: usize,
    set_h_len: usize,

    sum_1: &Poly,

    van_poly_vkx: &Poly,
    van_poly_vhx: &Poly,
) -> bool {
    println!("====================");
    check_equation_1(h_3x, g_3x, van_poly_vkx, ax, bx, beta_3, sigma_3, set_k_len);
    println!();
    check_equation_2(
        poly_r,
        h_2x,
        g_2x,
        van_poly_vhx,
        beta_2,
        sigma_2,
        sigma_3,
        set_h_len,
    );
    println!();
    check_equation_3(
        poly_sx,
        sum_1,
        poly_z_hat_x,
        h_1x,
        g_1x,
        van_poly_vhx,
        beta_1,
        sigma_1,
        sigma_2,
        set_h_len,
    );
    println!();
    check_equation_4(poly_ab_c, poly_h_0, van_poly_vhx, beta_1);
    println!("====================");

    check_equation_1(h_3x, g_3x, van_poly_vkx, ax, bx, beta_3, sigma_3, set_k_len)
        && check_equation_2(
            poly_r,
            h_2x,
            g_2x,
            van_poly_vhx,
            beta_2,
            sigma_2,
            sigma_3,
            set_h_len,
        )
        && check_equation_3(
            poly_sx,
            sum_1,
            poly_z_hat_x,
            h_1x,
            g_1x,
            van_poly_vhx,
            beta_1,
            sigma_1,
            sigma_2,
            set_h_len,
        )
        && check_equation_4(poly_ab_c, poly_h_0, van_poly_vhx, beta_1)
}


fn kzg(poly_in: &Poly, d: u64, g: u64) -> Mfp {
    let mut res_poly = Mfp::ONE;

    if let Degree::Num(deg) = poly_in.degree() {
        let mut s = Mfp::from(g);
        let d = d % (P - 1);

        for i in 0..=deg {
            let coef = poly_in.terms[deg - i].into_bigint().0[0];
            let value = exp_mod(s.into_bigint().0[0], coef);
            res_poly *= value;
            s = exp_mod(s.into_bigint().0[0], d);
        }
    }

    if res_poly == Mfp::ONE {
        Mfp::from(g)
    } else {
        res_poly
    }
}

#[cfg(test)]
mod math_test {
    use super::*;

    #[test]
    fn test_exp_mod() {
        assert_eq!(exp_mod(2, 0), Mfp::ONE);
        assert_eq!(exp_mod(10, 0), Mfp::ONE);

        assert_eq!(exp_mod(2, 1), Mfp::from(2));
        assert_eq!(exp_mod(10, 1), Mfp::from(10));

        assert_eq!(exp_mod(2, 3), Mfp::from(8));
        assert_eq!(exp_mod(3, 2), Mfp::from(9));
        assert_eq!(exp_mod(5, 3), Mfp::from(125));

        assert_eq!(exp_mod(2, 10), Mfp::from(1024));
        assert_eq!(exp_mod(3, 5), Mfp::from(243));

        assert_eq!(
            exp_mod(987654321987654321, 1234567890123456789),
            Mfp::from(42)
        );
        assert_eq!(
            exp_mod(887654448019654120, 1139562969472691009),
            Mfp::from(55)
        );
        assert_eq!(exp_mod(u64::MAX, 9223372036854775807), Mfp::from(65));
    }

    #[test]
    fn test_func_u() {
        assert_eq!(
            Poly::new(vec![Mfp::from(1)]),
            func_u(Some(Mfp::from(1)), Some(Mfp::from(0)), 100)
        );
        assert_eq!(
            Poly::new(vec![Mfp::from(1)]),
            func_u(Some(Mfp::from(0)), Some(Mfp::from(1)), 100)
        );
        assert_eq!(
            Poly::new(vec![Mfp::from(70)]),
            func_u(Some(Mfp::from(10)), Some(Mfp::from(1)), 5)
        );
        assert_eq!(
            Poly::new(vec![Mfp::from(53)]),
            func_u(Some(Mfp::from(123)), Some(Mfp::from(321)), 10)
        );
        assert_eq!(
            Poly::new(vec![Mfp::from(99)]),
            func_u(Some(Mfp::from(2838193)), Some(Mfp::from(9728224)), 50)
        );
        assert_eq!(
            Poly::new(vec![Mfp::from(63)]),
            func_u(Some(Mfp::from(!1)), Some(Mfp::from(!0)), 10)
        );
    }

    #[test]
    fn test_interpolate() {
        let points1 = [
            (1, 3),
            (4, 5),
            (10, 22),
            (111, 222),
            (0, 0),
            (0, 0),
            (1234, 4567),
            (122222, 1344556),
        ];
        let points2 = [
            (39942, 123244),
            (41221133, 53534213),
            (12121210, 2424222),
            (1242411, 242422),
            (0, 0),
        ];

        let points1: Vec<Point> = points1
            .iter()
            .map(|v| (Mfp::from(v.0), Mfp::from(v.1)))
            .collect();
        // 86x^7 + 178x^6 + 141x^5 + 52x^4 + 42x^3 + 47x^2
        let polynomial_points1 = Poly::new(vec![
            Mfp::from(86),
            Mfp::from(178),
            Mfp::from(141),
            Mfp::from(52),
            Mfp::from(42),
            Mfp::from(47),
            Mfp::from(0),
            Mfp::from(0),
        ]);

        let points2: Vec<Point> = points2
            .iter()
            .map(|v| (Mfp::from(v.0), Mfp::from(v.1)))
            .collect();
        // 68x^4 + 70x^3 + 35x^2 + 146x
        let polynomial_points2 = Poly::new(vec![
            Mfp::from(68),
            Mfp::from(70),
            Mfp::from(35),
            Mfp::from(146),
            Mfp::from(0),
        ]);

        assert_eq!(polynomial_points1, lagrange_interpolate(&points1));
        assert_eq!(polynomial_points2, lagrange_interpolate(&points2));
    }
}
